Алгоритмы, связанные со строками
Что вы узнаете
В этом материале мы разберём следующие алгоритмические действия:
⦁   поиск символа в строке,
⦁   поиск подстроки в строке,
⦁   проверку палиндрома.
Также вы сможете оценить эффективность решения типовых алгоритмических задач.

Поиск символа в строке
Начнём с простого и попробуем реализовать линейный поиск символа в строке.
Так как нам необходимо найти один конкретный символ, а в строке — n символов, то проверить в худшем
случае нужно будет все элементы. А значит, сложность будет равна O(n) — сколько элементов, столько
и сравнений.
# Задаём исходные данные
target = "a"
text = "mhtirogla"

# Инициализируем переменную для проверки успеха поиска
success = False

# Запускаем цикл по каждому символу в тексте
for letter in text:
# Сравниваем текущую букву с искомой
if letter == target:
# Если совпадение найдено, обновляем статус и прерываем цикл
success = True
break

# Выводим результат поиска
if success:
print("Буква была найдена в строке")
else:
print("Буквы в строке нет")
В строке было девять букв, цикл сработал девять раз, и мы нашли нужную букву. Всё сходится, и
сложность O(n) подтвердилась, но что, если бы мы выполняли поиск в строке “algorithm”? Тогда бы мы
нашли букву, а на первой же итерации, цикл бы завершился и, получается, сложность была бы O(1)?
Нет :) О большое говорит как раз о худшем случае для алгоритма. Когда мы пишем О(n), мы гарантируем,
что, даже если всё будет плохо, мы найдём букву максимум за O(n). При этом полезно попробовать
вычислить сложность для лучшего случая и крайне полезно — для среднего.

Поиск подстроки в строке
Усложним предыдущую задачу: попробуем найти не один символ в строке, а маленькую строку внутри
большой (подстроку в строке).
Вернёмся к задаче:
main_string = 'Hello world!' — основная строка.
sub_string = 'ow' — подстрока, которую алгоритм будет искать в основной строке.
Нужно узнать, есть ли в строке такая подстрока.
Для решения «в лоб», с перебором всех вариантов, нужно пройти почти по всем символам строки и проверить,
не начинается ли с текущего символа искомая нами подстрока. Мы берём символ, а затем начинаем цикл,
сравнивая этот символ и следующие с подстрокой.
Подготовим вспомогательные переменные:
# Нам нужны будут длины строки и подстроки
main_length = len(main_string)
sub_length = len(sub_string)
# И нужен будет указатель, который мы изменим, если строка будет найдена
success = False

# Мы можем проходить не по всей строке.
# Например, если мы ищем подстроку из шести букв в слове из десяти букв,
# то проверить нужно только первые четыре буквы, так как подстрока просто не поместится в остатке
строки, если поиск будет начинаться с пятой буквы.
# Пример:
# “1122334455” — весь текст;
# “123456” — подстрока, которую ищем.
# Надо проверить следующие варианты:
# начинаем с первого символа и проверяем шесть символов (столько, сколько их в подстроке)
# “112233” == “123456”?
# строки не равны, берём второй символ
# “122334” == “123456”?
# тоже нет
# “223344” == “123456”?
# “233445” == “123456”?
# “334455” == “123456”?
# А вот дальше двигаться нет смысла, так как в строке осталось всего пять символов и они точно не
могут быть равны подстроке из шести символов:
# “34455” != “123456”
# Значит, наш цикл должен был пройти от 0 до 4 (10 − 6 = 4) включительно.
# Тогда, чтобы найти количество итераций в коде, нам нужно посчитать:
# (длина главной строки − длина подстроки + 1).
# +1 нужен, чтобы range дошёл до полученного числа включительно
count = main_length - sub_length + 1
for i in range(count):
j = 0
# j — счётчик для подсчёта совпадений
while j < sub_length and main_string[i + j] == sub_string[j]:
# Цикл продолжается, пока:
# 1) количество совпадений меньше длины подстроки (если они будут равны, то дальше проверку
делать нет смысла);
# 2) взятые символы равны (с помощью j мы перебираем символы в строке, i используем как сдвиг,
чтобы брать из главной строки срез, начиная с текущего символа).
j += 1


# Если после вложенного цикла число j равно длине подстроки,
# это значит, что мы нашли подстроку в нашей строке, цикл можно прерывать
if j == sub_length:
success = True
break

# После цикла мы проверяем success и делаем итоговый вывод
if success:
print('Подстрока найдена!')
else:
print('Такой подстроки в строке нет :(')
Этот метод может быть неэффективным для длинных строк, так как его сложность
составляет O(main_length * sub_length), где main_length — длина строки, а sub_length — длина подстроки.
Однако это простой и понятный способ реализовать поиск подстроки в строке.
В следующих модулях мы ещё вернёмся к этой задаче и разберём более эффективные и сложные
алгоритмы для её решения.
