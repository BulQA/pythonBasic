Проверка палиндрома
Палиндром — слово, фраза или последовательность символов, которые читаются одинаково слева направо
и справа налево. Например, слова «довод» и «комок» — палиндромы, потому что они читаются одинаково
в обоих направлениях. Также палиндромами могут быть числа, такие как 121 или 12321. Палиндромы
используют в криптографии, играх со словами и других приложениях, связанных со строками.
Если нам дают строку text и говорят проверить, является ли она палиндромом, нужно убедиться, что
символы её первой половины равны символам второй. Сделать это можно разными способами — мы рассмотрим
несколько самых простых, которые можно реализовать без изучения дополнительных инструментов
(кроме разве что индексов).

Вариант 1 (без использования индексов)
text = 'довод'
reversed_text = ''

# Проходим по всей строке
for letter in text:
     # Каждый символ строки добавляем В НАЧАЛО новой строки
     reversed_text = letter + reversed_text

# В итоге в reversed_text мы получим перевёрнутую строку.
# Если строки равны, слово является палиндромом
if text == reversed_text:
     print('Это палиндром!')
else:
     print('Не палиндром!')
Так как для этого алгоритма нам надо пройти по каждому элементу строки, сложность такого алгоритма будет
равна O(n).

Вариант 2 (с использованием индексов)
# Возьмём тот же текст
text = 'довод'
# Нам понадобится узнать его длину
text_length = len(text)
# И вспомогательный флаг
success = True


# За одну итерацию мы будем проверять два символа (с начала и с конца),
# поэтому итераций можно сделать в два раза меньше (text_length // 2):
for i in range(text_length // 2):
     # На каждой итерации сравниваем два символа:
     # символ с начала text[i] с символом с конца text[-i - 1]
     if text[i] != text[-i - 1]:
         # Если хотя бы одна пара символов не совпадёт, то меняем флаг и завершаем цикл
         success = False
         break

# Если все символы совпадают, то строка является палиндромом, иначе — нет
if success:
     print('Это палиндром!')
else:
     print('Не палиндром!')
Обратите внимание: здесь мы перебираем не все элементы строки, а половину (длина строки // 2).
Делаем мы это, потому что за одну итерацию проверяем сразу два символа, один — с начала строки
индекс i), другой — с конца (-i - 1),
а центральный символ нам вообще проверять нет необходимости.
Получается, что этот алгоритм эффективнее предыдущего — его сложность примерно равна O(n/2).
Она не дотягивает до O(log n), но это всё же лучше, чем O(n).

